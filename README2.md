JAVA

==========================================================
변수

기본형 : 실제 연산에 사용
  - 정수형 : byte(1) , short(2) , int(4) , long(8)
  - 실수형 : float(4) , double(8)
  - 문자형 : char(2)
  - 논리형 : boolean

선언
변수 만 선언
int num; // 변수의 선언
System.out.println(num); // 오류 발생 : 변수 내 데이터 없음
num = 20; // 변수의 초기화
System.out.println(num); // 20

선언과 동시에 초기화
int num1, num2; // 같은 타입의 변수를 동시에 선언함.
double num3 = 3.14; // 선언과 동시에 초기화함
double num4 = 1.23, num5 = 4.56;

오류
double num1 , num2;
num1 = 1.23 , num2 = 4.56; // 이미 선언 된 여러 변수를 동시에 초기화는 불가능.

==========================================================
상수

변수와 마찬가지로 이름을 가지고 있는 메모리 공간.
상수는 선언과 동시에 반드시 초기화.

ex) final int AGES = 30; // final 키워드를 사용하여 선언

==========================================================
리터럴 (literal)

그 자체로 값을 의미하는 것.
변수와 상수와 달리 데이터가 저장된 메모리 공간을 가리키는 이름을 가지고 있지 않음.(( 변수명 X ))
ex) int var = 30; // 리터럴 = 30
    final int AGES = 100; // 리터럴 = 100

타입에따른 리터럴
1.정수형 리터럴은 123, -456 과 같이 아라비아 숫자와 부호로 직접 표현
2.실수형 리터럴은 3.14, -45.6과 같이 소수부분을 가지는 아라비아 숫자로 표현
3.논리형 리터럴은 true 나 false 로 표현
4.문자형 리터럴은 'a','Z'와 같이 작은따옴표(' ')로 감싸진 문자로 표현
5.문자열 리터럴은 "자바" , "홍길동" 과 같이 큰따옴표(" ")로 감싸진 문자열로 표현
6.null 리터럴은 단 하나의 값인 null로 표현

리터럴 타입 접미사
long형 : L 또는 l . ex)123456789L, ...
float형 : F 또는 f . ex)1.234567F , 8.9f ...
double : D 또는 d ( 생략 가능 ) . ex)1.2345D , 6.789d

==========================================================

기본 타입

정수형타입
1.byte : 1byte : -128 ~ 127
2.short : 2byte : -32,768 ~ 32,767
3.int : 4byte : -2,147,483,648 ~ 2,147,483,647
4.long : 8byte : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

실수형타입
1.float : 4byte
2.double : 8byte

문자형타입
1.char : 2byte

논리형타입
1.boolean : 1byte : true or false

==========================================================

타입 변환

타입 변환의 종류
1.묵시적 타입 변환(자동 타입 변환)
  -대입 연산 이나 산술 연산 에서 컴파일러가 자동으로 수행해주는 타입 변환

byte > short > int > long > float > double
          char >^

2.명시적 타입 변환(강제 타입 변환)
  -사용자가 타입 캐스트 연산자 ( ( ) ) 를 사용하여 강제적으로 수행하는 타입 변환

(변환 할 타입) 변환 할 데이터
ex) float A = 30.52
    int B = (int) A;
    System.out.println(B); // 30

==========================================================

연산자(operator)

1.산술 연산자
  - + : 왼쪽의 피연산자에 오른쪽의 피연산자를 더함
  - - : 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌
  - * : 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함
  - / : 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔 ( 몫 )
  - % : 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔 ( 나머지 )

2.대입 연산자
  - = : 왼쪽의 피연산자에 오른쪽의 피연산자를 대입함
  - += : 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후 , 그 결과값을 왼쪽의 피연산자에 대입함.
  - -= : 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결과값을 왼쪽의 피연산자에 대입함.
  - *= : 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결과값을 왼쪽의 피연산자에 대입함.
  - /= : 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결과값인 몫 을 왼쪽의 피연산자에 대입함.
  - %= : 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결과값인 나머지 를 왼쪽의 피연산자에 대입함.
  - &= : 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 AND 연산한 후, 그 결과값을 왼쪽의 피연산자에 대입함.
  - |= : 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 OR 연산한 후, 그 결과값을 왼쪽의 피연산자에 대입함.
  - ^= : 왼쪽의 피연산자를 오른쪽의 피연산자와 비트 XOR 연산한 후, 그 결과값을 왼쪽의 피연산자에 대입함.
  - <<= : 왼쪽의 피연산자를 오른쪽의 피연산자만큼 왼쪽 시프트한 후, 그 결과값을 왼쪽의 피연산자에 대입함.
  - >>= : 왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호를 유지하며 오른쪽 시프트한 후, 그 결과값을 왼쪽의 피연산자에 대입함.
  - >>>= : 왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호에 상관없이 오른쪽 시프트한 후, 그 결과값을 왼쪽의 피연산자에 대입함.

3.증감 연산자
  - ++x : 먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함.
  - x++ : 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴.
  - --x : 먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함.
  - x-- : 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴.

4.비교 연산자
  - == : 왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 참을 반환함.
  - != : 왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함.
  - > : 왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 참을 반환함.
  - >= : 왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 참을 반환함.
  - < : 왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 참을 반환함.
  - <= : 왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 참을 반환함.

5.논리 연산자
  - && : 논리식이 모두 참이면 참을 반환함. ( 논리 AND 연산 )
  - || : 논리식 중에서 하나라도 참이면 참을 반환함. ( 논리 OR 연산 )
  - ! : 논리식의 결과가 참이면 거짓을 , 거짓이면 참을 반환함 ( 논리 NOT 연산 )

6.비트 연산자
  - & : 대응되는 비트가 모두 1이면 1을 반환함 ( 비트 AND 연산 )
  - | : 대응되는 비트중에서 하나라도 1이면 1을 반환함 ( 비트 OR 연산 )
  - ^ : 대응되는 비트가 서로 다르면 1을 반환함 ( 비트 XOR 연산 )
  - ~ : 비트가 1이면 0으로 , 0이면 1로 반전시킴 ( 비트 NOT연산, 1의 보수 )
  - << : 명시된 수만큼 비트들을 전부 왼쪽으로 이동시킴 ( left shift 연산 )
  - >> : 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴 ( right shift 연산 )
  - >>> : 지정한 수만큼 비트를 전부 오른쪽으로 이동시키며 , 새로운 비트는 전부 0이됨

7.삼항 연산자
  - 조건식 ? 반환값1 : 반환값 2
  조건식이 참일경우 반환값1을 반환 , 거짓일 경우 반환값 2를 반환.

8.instanceof 연산자
  - 인스턴스이름 instanceof 클래스또는인터페이스이름
  왼쪽 피연산자인 인스턴스가 오른쪽 피연산자인 클래스나 인터페이스로부터 생성되었으면 true를 반환하고, 그렇지않으면 false를 반환

==========================================================

메모리 구조

메소드(method) 영역
  - 클래스에 대한 정보와 함께 클래스변수가 저장되는 영역.
  - JVM은 자바 프로그램에서 특정클래스가 사용되면 해당 클래스의 파일 (*.class) 를 읽어들여, 해당클래스에 대한 정보를 메소드 영역에 저장.

힙(heap) 영역
  - 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역.
  - JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장.
  - 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당.

스택(stack) 영역
  - 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역.
  - JVM은 자바 프로그램에서 메소드가 호출되면, 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장.
  - 메소드의 호출과함께 할당, 호출이 완료되면 소멸.
  - 메소드의 호출정보를 스택프레임(stack frame) 이라고함.
  - 푸시(push) 동작으로 데이터를 저장, 팝(pop) 동작으로 데이터를 인출.
  - 후입선출 방식에따라 동작하므로, 가장늦게 저장된 데이터가 가장 먼저 인출.
  - 메모리의 높은 주소에서 낮은 주소의 방향으로 할당.

==========================================================

배열
  - 배열은 같은 타입의 변수들로 이루여진 유한 집합.
  - 배열을 구성하는 각각의 값을 배열요소(element) 라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index) 라고 함.
  - 자바에서 인덱스는 언제나 0부터 시작, 0을 포함한 양의 정수만을 가짐.
  - 선언되는 형식에따라 1차원배열 , 2차원배열뿐 아니라 그이상의 다차원 배열로도 선언가능. 하지만 현실적으로 이해하기 쉬운 2차원 배열까지 많이 사용

1차원배열
  - 타입[] 배열명;  ex ) int[] array;
  - 타입 배열명[];  ex ) int array[];
  - 배열이름 = new 타입[배열길이] ex ) array = new int[10] <<< 10개의 요소가 입력될 수 있는 배열 array.

배열의 초기화
  - 타입[] 배열명 = { 배열요소1, 배열요소2, ... }; ex ) int[] array = { 1, 2, 3,.... };
  - 타입[] 배열명 = new 타입[]{ 배열요소1, 배열요소2, ... }; ex ) int[] array = new int[]{ 1, 2, 3,.... };

2차원 배열
  - 2차원 배열이란 배열의 요소로 1차원 배열을 가지는 배열.
  - 자바에서는 2차원 배열을 나타내는 타입을 따로 제공하지는 않음.
  - 1차원 배열의 배열요소로 또다른 1차원 배열을 사용하여 2차원 배열을 나타낼 수 있음.

  - 타입[][] 배열명;  ex ) int[][] array;
  - 타입 배열명[][];  ex ) int array[][];
  - 타입[] 배열명[];  ex ) int[] array[];

배열의 선언과 동시에 초기화
  - 타입 배열명[열의길이][행의길이] = {
	{배열요소[0][0], 배열요소[0][1], ...},
	{배열요소[1][0], 배열요소[1][1], ...},
	{배열요소[2][0], 배열요소[2][1], ...},
	....
};

  ex ) int array[3][3] = {
	{10,20,30},
	{40,50,60},
	{70,80,90}
};

==========================================================

클래스의 개념

객체 지향 프로그래밍(OOP , Object-Oriented Programming)
  - 모든 데이터를 객체(object)로 취급하며, 이러한 객체가 바로 프로그래밍의 중심이 됨.
  - 객체의 상태와 행동을 구체화하는 형태의 프로그래밍이 객체 지향 프로그래밍
  - 객체를 만들어 내기위한 설계도와 같은 개념을 클래스 라고 함.

클래스
  - 객체를 정의하는 틀 또는 설계도와 같은 의미, 이러한 설계도를 가지고, 여러 객체를 생성하여 사용.
  - 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성. 즉, 필드란 클래스에 포함된 변수를 의미.
  - 메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합.

인스턴스
  - 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체를 선언해야 함
  - 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스화 라고 함.
  - 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스 라고함. 즉, 인스턴스란 메모리에 할당된 객체를 의미
  - 하나의 클래스로부터 여러개의 인스턴스를 생성할 수 있음. 이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있음.
  - 해당 클래스의 모든 메소드는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 됨.

메소드
  - 클래스는 멤버를 속성으로 표현하는 필드와 기능을 표현하는 메소드를 가짐.
  - 메소드란 어떠한 특정작업을 수행하기 위한 명령문의 집합.

  - 문법 -
  접근제어자 반환타입 메소드이름(매개변수목록) { // 선언부
	// 구현부
  }

  - 접근제어자 : 해당 메소드에 접근할 수 있는 범위를 명시
  - 반환 타입 : 메소드가 모든 작업을 마치고 반환하는 데이터 타입을 명시
  - 메소드명 : 메소드를 호출하기 위한 이름
  - 매개변수 목록 : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시
  - 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합

  - 오버로딩 : 같은 이름의 메소드를 중복하여 정의하는 것.
  - 매개변수의 개수나 타입을 다르게 하면, 하나의 메소드명 으로 여러개의 메소드 작성 가능.
  - 반환타입은 오버로딩에 영향을 주지 않음

==========================================================

접근 제어자

  - private : private 멤버는 해당 멤버를 선언한 클래스에서만 접근할 수 있음.
  - public : public 멤버는 프로그램 어디에서 누구나 접근할 수 있음.
  - default : default 멤버는 같은 패키지에 속하는 클래스에서만 접근할 수 있음.
  - protected : protected 멤버는 같은 패키지에 속하는 클래스와 다른 패키지에 속하는 자식 클래스에서만 접근할 수 있음.

접근제어자	같은 클래스의 멤버		같은 패키지의 멤버		자식클래스의 멤버		그외의영역

public			O			O			O		      O
protected		O			O			O		      X
default			O			O			X		      X
private			O			X			X		      X

==========================================================

기타 제어자

final 제어자
  - final 제어자 : 자바에서 final제어자는 "변경할 수 없다" 는 의미로 사용.
  - 즉, 필드나 지역변수에 사용하면 값을 변경할 수 없는 상수가 됨.
  - 클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없게 됨.
  - 메소드에 사용하면 해당 메소드는 오버라이딩을 통한 재정의를 할 수 없게 됨.

final 제어자를 사용할 수 있는 대상
  : Class , Method , Field , Local variable

static 제어자
  - static 제어자 : '공통적인' 이라는 의미로 사용
  - 즉, static제어자를 변수에 사용하면 해당 변수를 클래스 변수로 만들어줌.
  - 메소드에 사용하면 해당 메소드를 클래스 메소드로 만들어줌.
  - static 제어자는 초기화 블록에도 사용 가능.

특징
  : 프로그램 시작시 최초에 단 한 번만 생성되고 초기화.
    인스턴스를 생성하지 않고도 바로 사용할 수 있음.
    해당 클래스의 모든 인스턴스가 공유함.

abstract 제어자
  - abstract 제어자 : '추상적인' 이라는 의미로 사용
  - 선언부만 있고 구현부가 없는 메소드를 추상 메소드라 하며, 반드시 abstarct 제어자를 붙여야 함
  - 하나 이상의 추상 메소드가 포함하고 있는 추상 클래스도 반드시 abstract 제어자를 붙여야 함

abstract 제어자를 사용할 수 있는 대상
  : Class , Method

제어자의 조합
클래스 : public , (default) , final , abstract
메소드 : 모든 접근 제어자 , final , static , abstract
필드 : 모든 접근 제어자 , final , static
지역 변수 : final
초기화 블록 : static

1. 클래스에 final과 abstract는 함께 사용할 수 없음.
2. 메소드에 static과 abstract는 함께 사용할 수 없음.
3. 메소드에 private와 abstract는 함께 사용할 수 없음.
4. 메소드에 private와 final은 함께 사용할 필요가 없음.

==========================================================

필드의 구분

변수			생성시기			소멸시기			저장메모리		사용방법

클래스 변수	클래스가 메모리에 올라갈때		프로그램이 종료될 때	메소드 영역		클래스이름.변수이름
인스턴스 변수	인스턴스가 생성될 때		인스턴스가 소멸할 때	힙 영역			인스턴스이름.변수이름
지역 변수		블록 내에서 변수의 선언문이 실행될때	블록을 벗어날 때		스택 영역			변수이름

메소드의 구분

1.클래스 메소드 : static 키워드를 가지는 메소드
2.인스턴스 메소드 : static 키워드를 가지지 않는 메소드

  - 클래스 메소드는 클래스 변수와 마찬가지로 인스턴스를 생성하지 않고도 바로 사용 가능
  - 클래스 메소드는 메소드 내부에서 인스턴스 변수 사용 불가.
  - 메소드 내부에서 인스턴스 변수나 인스턴스 메소드를 사용하지 않는 메소드를 클래스 메소드로 정의하는 것이 일반적

필드의 초기화

1. 명시적 초기화
2. 생성자를 이용한 초기화
3. 초기화 블록을 이용한 초기화

ex ) 
class Field {
    static int classVar = 10; // 클래스 변수의 명시적 초기화
    int instanceVar = 20; // 인스턴스 변수의 명시적 초기화
}

초기화 블록

1. 인스턴스 초기화 블록
  - 단순히 중괄호만을 사용하여 정의할 수 있음.
  - 생성자와 마찬가지로 인스턴스가 생성될 때마다 실행.
  - 언제나 생성자보다 먼저 실행.
  - 여러 개의 생성자가 있으면 모든 생성자에서 공통으로 수행되어야 할 코드를 포함하여 코드의 중복을 막을 수 있음.
2. 클래스 초기화 블록
  - 인스턴스 초기화 블록에 static 키워드를 추가하여 정의할 수 있음.
  - 처음으로 메모리에 로딩될 때 단 한 번만 실행.
  - 인스턴스 초기화 블록으로는 수행할 수 없는 클래스 변수의 초기화를 수행할 때 사용됨.

필드의 초기화 순서

1. 클래스변수 : 기본값 > 명시적 초기화 > 클래스 초기화 블록
2. 인스턴스변수 : 기본값 > 명시적 초기화 > 인스턴스 초기화 블록 > 생성자

==========================================================

상속

  - 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는것을 의미.
  - 캡슐화 , 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나.
  - 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있음.

부모클래스 == 상위클래스 == 기초클래스
	         v 상속 v
자식클래스 == 하위클래스 == 파생클래스

자식클래스
  - 부모클래스의 모든 특성을 물려받아 새롭게 작성된 클래스를 의미.
  - 부모 클래스에 필드를 하나 추가하면, 자식 클래스에서도 자동으로 해당 필드가 추가된 것 처럼 동작.
  - 자식 클래스에는 부모 클래스의 필드와 메소드만이 상속, 생성자와 초기화 블록은 상속되지 않음.
  - 부모 클래스의 접근 제어자가 private나 default로 설정된 멤버는 자식 클래스에서 상속 받지만 접근할 수는 없음

Object 클래스

  - Object 클래스는 모든 클래스의 부모 클래스가 되는 클래스.
  - 모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 됨.
  - 모든 클래스는 별도로 extends 키워드를 사용하여 Object 클래스의 상속을 명시하지 않아도 Object 클래스의 모든 멤버를 자유롭게 사용가능.
  - 모든 객체에서 toString() 이나 clone() 과 같은 메소드를 바로 사용할 수 있는 이유가 해당 메소드들이 Object클래스의 메소드이기 때문.

==========================================================

메소드 오버라이딩
  - 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것
  - 자식 클래스는 부모 클래스의 private 멤버를 제외한 모든 메소드를 상속 받음.
  - 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 재정의하여 사용할 수도 있음.
  - 메소드 오버라이딩이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것.
