# Study
추상클래스 : 추상 메소드를 포함하고 있는 클래스
 - 추상메소드를 포함하고 있다는 점 외에는 일반 클래스와 전혀 다르지 않음.
 - 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상 클래스로서의 중요한 역할을 함.
 - 접근제한자 뒤에 abstract 를 선언함.
 
추상메소드 : 선언부만 작성하고 구현부는 작성하지 않은 메소드
 - 실제 내용은 상속받는 클래스에서 구현하도록 비워둠.
 - 추상클래스처럼 abstract 를 선언함.
 - 구현부가 위치할 {} 대신 ; 을 작성함.
 - 자식 클래스에서 추상 메소드를 반드시 구현하도록 강요하기 위해서.
 
인터페이스 : 객체의 사용 방법을 정의한 타입
 - 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할.
 - 개발 코드와 객체가 서로 통신하는 접점 역할.
 - 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출.
 - 따라서 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알면 됨.

		  >>메소드 호출>>     	  >>메소드 호출>> 
	개발코드			  인터페이스				객체
		  << 리턴 값 <<  		  << 리턴 값 << 
		  
 - 인터페이스 내에 존재하는 메서드는 무조건 public abstract로 선언되며, 이를 생략할 수 있음.
 - 인터페이스 내에 존재하는 변수는 무조건 public static final로 선언되며, 이를 생략할 수 있음.

인터페이스 사용이유
 - 개발 시간 단축
	: 다른 개발자들이 각각의 부분을 완성할 때 까지 기다리지 않고 서로 규약만 정해두어 각자의 부분만 따로 나눠서 작성된 코드를 컴파일 할 수 있음.
 - 클래스간 결합도 하락
	: 코드의 종속성을 줄이고 유지보수성을 높임.
 - 표준화 가능
	: 클래스의 기본틀을 제공하여 개발자들에게 정형화된 개발을 강요할 수 있음.
 - 개발 코드를 수정하지 않고, 사용하는 객체를 변경할 수 있도록 하기위해.
 - 개발 코드 측면에서는 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있다는 장점.
 
인터페이스 선언 방식 : [ public ] interface 인터페이스명 { }
 - 인터페이스명은 영어 대소문자를 구분하며 첫문자 대문자, 이후의 문자를 소문자로 작성하는것이 관례
 - 클래스는 필드, 생성자, 메소드를 구성멤버로 가지는데 비해, 인터페이스는 상수와 메소드만을 구성 멤버로 가짐. (( 변수 : 단 하나의 값을 저장할 수 있는 메모리 공간 = 데이터 변경 가능 ))
 - 인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 없음.							  (( 상수 : 처음에 정해놓은 값이 바뀌지 않고 끝까지 가는 값 = 수정 불가 = final ))
 - 자바8버전 부터는 Default 메소드와 static 메소드도 선언 가능.
 
 ex)
 interface 인터페이스명{
 //상수
 int num = 4;
 //추상 메소드
 void Method(); 
 //디폴트 메소드
 default void Dmethod(){...}
 //정적 메소드
 static void Smethod(){...}
 }
 
상수필드
 - 인터페이스는 런타임 시 데이터를 저장할 수 있는 필드를 선언할 수 없음. 하지만 상수 필드는 선언 가능.
 - 상수를 선언할 때에는 반드시 초기값을 대입해야 함.
  
추상메소드
 - 객체가 가지고 있는 메소드를 설명한 것으로, 호출할 때 어떤 매개값이 필요하고 리턴 타입이 무엇인지만 알려줌.
 - 실제 실행부는 객체(구현객체)가 가지고 있음.

디폴트메소드
 - 인터페이스에 선언되지만 사실은 객체(구현객체)가 가지고 있는 인스턴스 메소드라고 생각해야 함. (( 인스턴스 메소드 : static 을 가지지 않은 메소드 ))
 - 자바8버전 부터 디폴트 메소드를 허용한 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해.

정적메소드
 - 디폴트메소드와는 달리 객체가 없어도 인터페이스만으로 호출이 가능함.

상수 필드 선언
 - 데이터를 저장할 인스턴스 또는 정적 필드를 선언할 수 없음. 대신 상수 필드만 선언 가능.
 ex)
 [ public static final ] 타입 상수명 = 값;
 - 상수명은 영어 대문자로, 다른 단어로 구성되어있을 경우 "_"를 이용하여 연결하는것이 관례
 ex)
 public interface RemoteControl{
	public int MAX_VOLUME = 10;
	public int MIN_VOLUME = 0;
 }
 
익명 클래스 : 클래스의 선언과 객체생성을 동시에 하기 때문에 단 한 번만 사용할 수 있고, 오직 하나의 객체만을 생성할 수 있는 일회용 클래스.
 - 이름이 없기 때문에 생성자를 가질수 없음.
 - 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있음.
 - 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없음.
 - 추상클래스 , 인터페이스는 원래 상속을 받아야만 사용이 가능 하지만, 익명클래스 에서는 익명구현 객체를 통해 사용 가능.
 
익명 구현 객체
 ex)
 인터페이스 변수 = new 인터페이스(){
 // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
 };
 - 두번이상 사용할 일이 없는 경우 익명구현 객체로 사용
 - 이름이 존재하지 않아 다른곳에서 호출이 불가함.
 
instanceof : 상속 , 인터페이스 에서 객체의 타입 확인
 ex)
 if( vehicle instanceof Bus ) {
	Bus bus = (Bus) vehicle
 }
 
람다식 : 익명함수를 생성하기 위한 식. 객체지향 언어보다 함수지향 언어에 가까움.
 - 람다의 기본 구조 : (타입 매개변수 , ...) -> {실행문;...};
 - 람다식이 대입 될 인터페이스를 람다식의 타켓타입 이라고 함.
함수적 인터페이스
 - @FunctionalInterface 어노테이션을 선언하여 함수적 인터페이스 임을 명시함.
 - 해당 어노테이션을 사용하면 선언된 인터페이스는 한개의 추상메소드만 생성할 수 있음.
 - 반대로, 한개의 추상메소드만 생성되어도 그 인터페이스는 함수적 인터페이스로 칭함.
 
컬렉션 프레임워크
List : ArrayList , Vector , LinkedList 
Set : HashSet , TreeSet
Map : HashMap , HashTable , TreeMap , Properties

 - ArrayList : List 인터페이스의 구현클래스, ArrayList가 추가되면 객체가 인덱스로 관리됨.
			 : 인덱스로 관리한다는 점 에서는 배열과 유사하지만 크기가 유동적이라는 차이점이 있음.
			 : List<String> list = new ArrayList<String>() << 기본적인 선언 방식. 초기용량을 10으로 선언해줌.
			 : List<String> list = new ArrayList<String>(30) << 초기용량을 30으로 지정할 경우의 선언.
			 : List list = new ArrayList(); << 기본적으로 모든 타입이 사용 가능하지만, 데이터를 불러올때마다 타입변환을 해줘야하는 단점이 있음.
			 : 따라서 제네릭을 사용하여 타입을 지정해주어 사용함. 이로인해 데이터를 불러올때 타입변환을 하지 않아도 됨.
			 : 데이터에 변화가 생길때, 중간 인덱스 데이터가 삭제되면 삭제된곳 이후의 데이터가 당겨서 빈자리를 채움.
			 : 반대로 중간 인덱스에 데이터를 추가하면 추가된곳 이후의 데이터가 한칸씩 밀려남.
			 : 마지막에 데이터를 추가하여 쌓아가는 방식이라면 ArrayList가 좋지만, 만약 데이터 수정이 빈번하고 중간데이터가 수시로 빠지는 형식이라면 LinkedList가 적합함.
 - Vector : ArrayList와 동일한 내부 구조를 가지고 있음.
		  : List<E> list = new Vector<E>(); << 객체타입을 타입 파라미터로 표기하고 기본 생성자를 호출
		  : ArrayList와 다른점은 Vector는 동기화된(synchronized) 메소드로 구성되어 있기 때문에 하나의 스레드가 실행을 완료해야만 다른스레드를 실행할 수 있음. (( 멀티스레드 X ))
		  
 - LinkedList : ArrayList와 사용방법은 똑같지만 내부구조는 완전 다름.
			  : ArrayList는 내부 배열에 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리함.
			  : LinkedList에서 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않음. 삽입시에도 마찬가지.
			  : 빈번한 객체 삭제와 삽입이 일어날경우 데이터에 변화가 일어날때 당겨지고 밀려지는 ArrayList에 비해 LinkedList가 더 좋은 성능을 발휘함.
 ArrayList 와 LinkedList 비교
	구분 			순차적으로 추가/삭제 		중간에 추가/삭제 			검색
	ArrayList		빠르다					느리다				빠르다	
	LinkedList		느리다					빠르다				느리다
	
 - HashSet : Set 인터페이스의 구현 클래스.
		   : Set<E> set = new HashSet<E>();
		   : 타입 파라미터 E 에는 저장할 객체 타입을 지정하면 됨.
		   : Set<String> set = new HashSet<String>(); << String 타입으로 사용하는 HashSet 선언.
		   : 객체들을 순서없이 저장하고 동일한 객체는 중복 저장하지 않음.
		   : HashSet이 판단하는 동일한 객체란 꼭 같은 인스턴스를 뜻하지는 않음.
		   : HashSet은 객체를 저장하기 전에 먼저 객체의 hashCode() 메소드를 호출해서 해시코드를 얻어냄. 그리고 이미 저장되어있는 객체들의 해시코드를 비교함.
		   : 만약 동일한 해시코드가 있다면 다시 equals() 메소드로 두 객체를 비교하고, true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않음.
		   
 - HashMap : Map 인터페이스를 구현한 대표적인 Map 컬렉션.
		   : Map<String, Integer> map = new HashMap<String, Integer>(); << 키를 String, 값을 Integer 타입으로 사용하는 HashMap 선언
		   : 주로 키 타입은 String을 많이 사용함.
		   : 키와 값의 타입은 기본타입(byte, short, int, float, double, boolean, char)을 사용할 수 없고 클래스 및 인터페이스 타입만 가능.
		   : Map.Entry << Map 인터페이스의 내부 인터페이스로 맵에 저장되는 엔트리의 조작을 위한 메소드가 정의되어 있음.
		   : Set<Map.Entry<K, V>> entryset = map.entrySet() << 해당 맵에 포함된 모든 매핑데이터를 Set 객체로 반환함.
 
 - HashTable : HashMap과 동일한 내부구조를 가지고 있음. 차이점은  HashTable은 동기화된(synchronized) 메소드로 구성되어 있기 때문에 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있음. (( 멀티스레드 X ))
			 : 그래서 멀티스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있음. 이것을 스레드가 안전(thread safe)하다 라고 말함.
			 : Map<K,V> map = new HashTable<K,V>();
			 : Map<String, Integer> map = new HashTable<String, Integer>(); <<< 키를 String, 값을 Integer 타입으로 사용하는 HashTable 선언
			 : map.containsKey(id) : id라는 key가 map안에 존재하는지 확인.
			 : map.get(id).equals(password) : id라는 key의 value가 password와 같은지 확인.

 - Properties : HashTable의 하위 클래스이기 때문에 HashTable의 모든 특징을 그대로 가지고 있음. 차이점은 HashTable은 키와 값을 다양한 타입으로 지정이 가능한데, Properties는 String타입으로 제한한 컬렉션임.
			  : Properties는 애플리케이션의 옵션정보, DB연결정보, 국제화(다국어) 정보가 저장된 프로퍼티 (~.properties) 파일을 읽을 때 주로 사용함.
			  : Properties 객체를 생성하고, load() 메소드를 호출하면 됨. load()메소드는 프로퍼티 파일로부터 데이터를 읽기위해 FileReader 객체를 매개값으로 받음.

이진 트리 구조 : 여러개의 노드(node)가 트리형태로 연결된 구조. 루트노드 라고 불리는 하나의 노드에서부터 시작해서 각 노드에 최대 2개의 노드를 연결할 수 있는 구조를 가지고 있음.
		  : 위아래로 연결된 노드를 부모-자식 관계에 있다고 하며, 위의노드를 부모노드 아래의노드를 자식노드라고 함. 하나의 부모노드는 최대 2개의 자식노드와 연결될 수 있음.
		  : 이진트리는 부모노드의 값보다 작은 노드는 왼쪽에, 큰 노드는 오른쪽에 위치시킴.
		  
 - TreeSet : 이진트리를 기반으로한 Set 컬렉션. 하나의 노드는 노드값인 value와 왼쪽과 오른쪽 자식노드를 참조하기 위한 두개의 변수로 구성됨.
		   : TreeSet에 객체를 저장하면 자동으로 정렬되는데 부모값과 비교해서 낮은것은 왼쪽 자식노드, 높은것은 오른쪽 자식노드에 저장.
		   : TreeSet<E> treeSet = new TreeSet<E>();
		   : TreeSet<String> treeSet = new TreeSet<String>(); <<< String 타입 객체를 저장하는 TreeSet

 - TreeMap : 이진트리를 기반으로한 Map 컬렉션. TreeSet과 차이점은 키와 값이 저장된 Map.Entry를 저장한다는 점.
		   : TreeMap에 객체를 저장하면 자동으로 정렬되는데 부모 키값과 비교해서 키 값이 낮은것은 왼쪽 자식노드, 높은것은 오른쪽 자식노드에 Map.Entry객체를 저장.
		   : TreeMap<K, V> treeMap = new TreeMap<K, V>();
		   : TreeMap<String, Integer> treeMap = new TreeMap<String, Integer>(); <<< Key를 String, Value를 Integer타입으로 한 TreeMap
		   : 특정 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위해서 주로 사용.
		   
LIFO 와 FIFO 컬렉션
 후입선출(LIFO: Last In First Out)은 나중에 넣은 객체가 먼저 빠져나가는 자료구조를 말함.
 선입선출(FIFO: First In First Out)은 먼저 넣은 객체가 먼저 빠져나가는 자료구조를 말함.
 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 큐(Queue) 인터페이스를 제공함.
 
 - Stack : Stack<E> stack = new Stack<E>();
 
 - Queue : Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList.
		 : Queue<E> queue = new LinkedList<E>();
		 
Stream : 컬렉션(배열 포함)의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있도록 해주는 반복자.
 스트림의 특징
	- Iterator와 비슷한 역할을 하는 반복자이지만, 람다식으로 요소 처리 코드를 제공하는점과 내부 반복자를 사용하므로 병렬 처리가 쉬움.
	- 중간처리와 최종 처리작업을 수행함.
	- Stream이 제공하는 대부분의 요소 처리 메소드는 함수적 인터페이스 매개타입을 가지기 때문에 람다식 또는 메소드 참조를 이용해서 요소처리 내용을 매개값으로 전달할 수 있음.
 Iterator는 컬렉션의 요소를 가죠오는 것에서부터 처리하는것 까지 모두 개발자가 작성해야 하지만 스트림은 람다식으로 요소 처리내용만 전달할 뿐, 반복은 컬렉션 내부에서 일어남.
 중간 처리 메소드와 최종 처리 메소드를 쉽게 구분하는 방법은, 중간 처리 메소드는 리턴타입이 Stream , 최종 처리 메소드는 기본타입이거나 OptionalXXX 임.
 소속된 인터페이스에서 공통의 의미는 Stream, IntStream, LongStream, DoubleStream에서 모두 제공된다는 뜻.
Stream 기능
(클래스명 :: 메소드명) : 해당 클래스 내의 해당 메소드를 실행.
 객체명.stream() : 해당 객체를 stream객체로 얻어옴
 .forEach(반복 대상) : stream안의 데이터를 내부적으로 반복문 실행.
 .filter(필터조건) : 조건에 해당하는 데이터만 가져옴
 .mapToInt(데이터) : 해당 데이터를 Int 타입으로 매핑함.
 .average() : 해당 데이터의 평균을 구함.
 .getAsDouble() : 해당 데이터를 Double형으로 변환함.
 .distinct() : 해당 stream내의 중복 데이터를 제거함.
 .sorted() : 숫자요소일 경우 오름차순으로 정렬.
		   : 객체요소일 경우 기본비교(Comparable)을 이용하여 객체요소의 클래스 내에서 기준 데이터를 잡고 오름차순 정렬.
		   : Comparator를 제공하여 이용할 경우 내림차순 정렬 가능.
		   : 객체요소일 경우 클래스가 Comparable을 구현하지 않으면 sorted()메소드를 호출했을 때 예외가 발생함.
 .peek() : forEach와 루핑한다는 기능은 동일하지만, peek() 메소드는 중간처리 메소드. 따라서 최종처리 메소드가 선언되지 않으면 실행되지 않음.
 .allMatch(조건) : stream의 데이터가 모두 조건에 맞는지 확인.
 .anyMatch(조건) : stream의 데이터가 하나라도 조건에 맞는지 확인.
 .noneMatch(조건) : stream의 데이터가 모두 조건과 다른지 확인.
 .count() : 해당 데이터의 개수를 출력.
 .sum() : 해당 데이터의 총 합을 출력.
 .avg() : 해당 데이터의 평균을 출력.
 .max() : 해당 데이터의 최대값을 출력.
 .min() : 해당 데이터의 최소값을 출력.
 .findFirst() : 해당 데이터의 첫번째 값을 출력.
 .isPresent() : 평균값의 여부를 확인함. 존재하면 true 리턴
 .orElse(디폴트값) : 데이터가 존재하지 않을 시 해당 디폴트 값으로 출력
